1. Where clause will apply filter row by row.
SELECT * FROM EMP WHERE SALARY > 10000;

2. Having works on aggregated data.
SELECT dept_id, avg(salary) FROM emp
GROUP BY dept_id
HAVING avg(salary) > 9500;

SELECT department_id, AVG(salary) FROM emp
WHERE salary > 10000
GROUP BY department_id
HAVING AVG(salary) > 15000;

3. CONVERT ROWS TO COLUMNS AND COLUMNS TO ROWS WITHOUT USING PIVOT FUNCTION
SELECT emp_id,
sum(CASE when salary_component_type = 'salary' then val end) as salary,
sum(CASE when salary_component_type = 'bonus' then val end) as bonus,
sum(CASE when salary_component_type = 'hike_percent' then val end) as hike_percent
FROM emp_compensation
GROUP BY emp_id;

4. Design another table as well
SELECT emp_id,
sum(CASE when salary_component_type = 'salary' then val end) as salary,
sum(CASE when salary_component_type = 'bonus' then val end) as bonus,
sum(CASE when salary_component_type = 'hike_percent' then val end) as hike_percent
into emp_compensation_pivot
FROM emp_compensation
GROUP BY emp_id;

5. Convert COLUMNS to ROWS

SELECT * FROM
(SELECT emp_id, 'salary' as salary_component_type, salary as val FROM emp_compensation_pivot
UNION ALL
SELECT emp_id, 'bonus' as salary_component_type, bonus as val FROM emp_compensation_pivot
UNION ALL
SELECT emp_id, 'hike_percent' as salary_component_type, hike_percent as val FROM emp_compensation_pivot
)
ORDER BY emp_id

1. How to find duplicates in a given table?
SELECT emp_id, COUNT(*) FROM EMP GROUP BY emp_id HAVING COUNT(*) > 1;

2. How to delete duplicates
SELECT * FROM EMP
with CTE as (SELECT *, row_number() over (partition by emp_id order by emp_id) as rn FROM EMP)
DELETE FROM CTE where rn > 1;

3. Difference btwn UNION AND UNION ALL
Union will give distinct/ unique values if we combine two tables. Whereas UNION ALL will completely combine both the tables as it is.

SELECT manager_id FROM EMPLOYEE
UNION
SELECT manager_id FROM EMPLOYEE

SELECT manager_id FROM EMPLOYEE
UNION ALL
SELECT manager_id FROM EMPLOYEE

4. RANK, DENSE_RANK, ROW_NUMBER
RANK will skip the next available ranking value
whereas DENSE_RANK would still use the next chronological ranking value
ROW_NUMBER() will give running number value

SELECT EMP_ID, DEPT_NAME, EMP_NAME
RANK() OVER(ORDER BY salary DESC) as RNK,
DENSE_RANK() OVER(ORDER BY salary DESC) as dense_rnk,
ROW_NUM() OVER(order by SALARY DESC) as rn
FROM EMP

NOTE: If you want rank department wise then
SELECT EMP_ID, DEPT_NAME, EMP_NAME
RANK() OVER(PARTITION BY dept_id ORDER BY salary DESC) as RNK,
DENSE_RANK() OVER(PARTITION BY dept_id ORDER BY salary DESC) as dense_rnk,
ROW_NUM() OVER(PARTITION BY dept_id order by SALARY DESC) as rn
FROM EMP

Interview Question: Highest salary in each department

SELECT * FROM
(SELECT EMP_ID, DEPT_NAME, EMP_NAME, salary
RANK() OVER(PARTITION BY dept_id ORDER BY salary DESC) as RNK FROM emp) a
WHERE rnk = 1;

5. Employees who are not present in department table.

SELECT * FROM emp WHERE department_id not in (SELECT dep_id FROM dept)

SELECT emp.*, dept.dept_id, dept.dep_name FROM emp
LEFT JOIN dept ON emp.department_id = dept.dep_id
WHERE dept.dep_name IS NULL;

6. Second highest salary in each department

SELECT * FROM (SELECT emp.*, DENSE_RANK() OVER(PARTITION BY department_name ORDER BY salary DESC) as rn FROM EMP) a 
WHERE rn = 2;

7. Find all transactions done by Shilpa

SELECT * FROM ORDERS WHERE customer_name = 'Shilpa';

SELECT * FROM ORDERS WHERE UPPER(customer_name) = 'SHILPA';

8. Give me records where employee_salary > manager_salary. Self Join (Table has emp_id, emp_name, deaprtment_id, salary, manager_id)

Self join is a regular join but the table is joined with itself

SELECT e.emp_id, e.emp_name, m.emp_name as MANAGER_NAME, e.salary, m.salary as MANAGER_SALARY
FROM emp e
INNER JOIN emp m
ON e.mananger_id = m.emp_id
WHERE e.salary > m.salary;

9. Joins


10. Update query to swap the gender
UPDATE orders
SET customer_gender = 
(CASE 
WHEN customer_gender = 'MALE' then 'FEMALE'
WHEN customer_gender = 'FEMALE' then 'MALE'
END)

                     









