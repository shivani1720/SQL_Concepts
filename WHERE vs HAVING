1. Where clause will apply filter row by row.
SELECT * FROM EMP WHERE SALARY > 10000;

2. Having works on aggregated data.
SELECT dept_id, avg(salary) FROM emp
GROUP BY dept_id
HAVING avg(salary) > 9500;

SELECT department_id, AVG(salary) FROM emp
WHERE salary > 10000
GROUP BY department_id
HAVING AVG(salary) > 15000;

3. CONVERT ROWS TO COLUMNS AND COLUMNS TO ROWS WITHOUT USING PIVOT FUNCTION
SELECT emp_id,
sum(CASE when salary_component_type = 'salary' then val end) as salary,
sum(CASE when salary_component_type = 'bonus' then val end) as bonus,
sum(CASE when salary_component_type = 'hike_percent' then val end) as hike_percent
FROM emp_compensation
GROUP BY emp_id;

4. Design another table as well
SELECT emp_id,
sum(CASE when salary_component_type = 'salary' then val end) as salary,
sum(CASE when salary_component_type = 'bonus' then val end) as bonus,
sum(CASE when salary_component_type = 'hike_percent' then val end) as hike_percent
into emp_compensation_pivot
FROM emp_compensation
GROUP BY emp_id;

5. Convert COLUMNS to ROWS

SELECT * FROM
(SELECT emp_id, 'salary' as salary_component_type, salary as val FROM emp_compensation_pivot
UNION ALL
SELECT emp_id, 'bonus' as salary_component_type, bonus as val FROM emp_compensation_pivot
UNION ALL
SELECT emp_id, 'hike_percent' as salary_component_type, hike_percent as val FROM emp_compensation_pivot
)
ORDER BY emp_id

1. How to find duplicates in a given table?
SELECT emp_id, COUNT(*) FROM EMP GROUP BY emp_id HAVING COUNT(*) > 1;

2. How to delete duplicates
SELECT * FROM EMP
with CTE as (SELECT *, row_number() over (partition by emp_id order by emp_id) as rn FROM EMP)
DELETE FROM CTE where rn > 1;

3. Difference btwn UNION AND UNION ALL
Union will give distinct/ unique values if we combine two tables. Whereas UNION ALL will completely combine both the tables as it is.

SELECT manager_id FROM EMPLOYEE
UNION
SELECT manager_id FROM EMPLOYEE

SELECT manager_id FROM EMPLOYEE
UNION ALL
SELECT manager_id FROM EMPLOYEE

4. RANK, DENSE_RANK, ROW_NUMBER
RANK will skip the next available ranking value
whereas DENSE_RANK would still use the next chronological ranking value
ROW_NUMBER() will give running number value

SELECT EMP_ID, DEPT_NAME, EMP_NAME
RANK() OVER(ORDER BY salary DESC) as RNK,
DENSE_RANK() OVER(ORDER BY salary DESC) as dense_rnk,
ROW_NUM() OVER(order by SALARY DESC) as rn
FROM EMP

NOTE: If you want rank department wise then
SELECT EMP_ID, DEPT_NAME, EMP_NAME
RANK() OVER(PARTITION BY dept_id ORDER BY salary DESC) as RNK,
DENSE_RANK() OVER(PARTITION BY dept_id ORDER BY salary DESC) as dense_rnk,
ROW_NUM() OVER(PARTITION BY dept_id order by SALARY DESC) as rn
FROM EMP

Interview Question: Highest salary in each department

SELECT * FROM
(SELECT EMP_ID, DEPT_NAME, EMP_NAME, salary
RANK() OVER(PARTITION BY dept_id ORDER BY salary DESC) as RNK FROM emp) a
WHERE rnk = 1;







